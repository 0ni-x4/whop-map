---
title: Complete Interactive Places Map with 3D Globe
description: "Build a comprehensive Mapbox-powered places management app where creators can add locations and customers can explore them on a beautiful 3D globe. Learn Whop API integration, access control, and map interaction patterns."
---

# Complete Interactive Places Map Tutorial

## What You'll Build

You'll create a sophisticated places management application that combines:
- **3D Globe Visualization**: Interactive Mapbox globe with custom pin markers
- **Whop Integration**: User authentication and role-based access control
- **Real-time Database**: PostgreSQL with Prisma ORM for place management
- **Admin Features**: Add/delete places with geocoding support
- **Customer Experience**: Beautiful read-only map exploration

## Understanding Whop: A Quick Primer

**Whop** is a platform for creators to sell digital products and experiences. Think of it like Shopify but for digital creators (courses, communities, software access, etc.).

### Key Whop Concepts:

1. **Experience**: A digital product/service that customers can purchase access to
2. **Companies (Biz)**: Creator businesses that sell experiences  
3. **Access Levels**: Different permission levels for users:
   - `admin`: Full control (usually the creator)
   - `customer`: Paid access to view/use the experience
   - `no_access`: No permission to view

### How This App Fits In:

Your places map is an **Experience** that creators can sell. Customers pay to access the interactive map, while creators (admins) can manage the places shown on it.

## 1. Set up your Next.js project

Clone our Next.js app template that includes Whop authentication:

```bash
npx create-next-app@latest places-map-app -e https://github.com/whopio/whop-nextjs-app-template
```

```bash
cd places-map-app
```

Install dependencies:

<CodeGroup>
```bash pnpm
pnpm i
```

```bash npm
npm i
```

```bash yarn
yarn i
```
</CodeGroup>

Run the app locally:

<CodeGroup>
```bash pnpm
pnpm dev
```

```bash npm
npm run dev
```

```bash yarn
yarn dev
```
</CodeGroup>

Open http://localhost:3000 and follow the setup instructions.

## 2. Configure Your Whop App

### Create Your Whop App

1. Go to [Whop Developer Dashboard](https://developers.whop.com)
2. Create a new app
3. Set the redirect URL to `http://localhost:3000/api/auth/callback/whop`
4. Copy your App ID and API Key

### Environment Variables

Add these to your `.env.local`:

```env .env.local
# Whop Configuration
WHOP_APP_ID=app_your_app_id
WHOP_API_KEY=whop_your_api_key  
MY_USER_ID=your_whop_user_id

# Database (we'll set this up next)
DATABASE_URL="postgresql://..."
DIRECT_URL="postgresql://..."

# Mapbox (we'll get this later)
NEXT_PUBLIC_MAPBOX_TOKEN=pk.your_mapbox_token

# App URL for forum post links
NEXT_PUBLIC_APP_URL=http://localhost:3000
```

**Important**: Install your app into your Whop business and switch to localhost mode for development.

## 3. Database Setup with Prisma

### Create Supabase Database

1. Go to [Supabase](https://supabase.com) and create a new project
2. Copy your database password
3. Go to Settings → Database → Connection pooling
4. Copy both connection strings (pooled and direct)

### Install Prisma

<CodeGroup>
```bash pnpm
pnpm add prisma @prisma/client
pnpm prisma init
```

```bash npm
npm install prisma @prisma/client
npx prisma init
```

```bash yarn
yarn add prisma @prisma/client
yarn prisma init
```
</CodeGroup>

### Database Schema

Create `prisma/schema.prisma`:

```prisma prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// Represents a Whop Experience (the product customers buy)
model Experience {
  id         String  @unique  // Whop Experience ID
  title      String           // Experience name from Whop
  webhookUrl String          // Optional webhook for notifications
  bizName    String          // Creator's business name
  bizId      String          // Whop business ID
  places     Place[]         // All places in this experience
}

// Individual places that appear on the map
model Place {
  id           String     @id @default(cuid())
  name         String                    // Display name
  description  String?                   // Optional description
  latitude     Float                     // GPS coordinates
  longitude    Float
  address      String?                   // Human-readable address
  category     String?                   // Optional grouping
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  experience   Experience @relation(fields: [experienceId], references: [id], onDelete: Cascade)
  experienceId String                    // Links to parent experience
}
```

### Database Operations

Update your `package.json` scripts:

```json package.json
{
  "scripts": {
    "prisma:generate": "prisma generate",
    "prisma:db:push": "prisma db push",
    "prisma:studio": "prisma studio"
  }
}
```

Generate and push schema:

<CodeGroup>
```bash pnpm
pnpm prisma:generate
pnpm prisma:db:push
```

```bash npm
npm run prisma:generate
npm run prisma:db:push
```

```bash yarn
yarn prisma:generate
yarn prisma:db:push
```
</CodeGroup>

## 4. Whop API Integration

### Understanding the Whop SDK

Create `lib/whop-api.ts`:

```typescript lib/whop-api.ts
import { WhopServerSdk, makeUserTokenVerifier } from "@whop/api";

// Main SDK instance for server-side API calls
export const whopApi = WhopServerSdk({
  // Your app's API key - required for all requests
  appApiKey: process.env.WHOP_API_KEY ?? "fallback",
  
  // Optional: User to make requests on behalf of
  // Usually your own user ID for app-level operations
  onBehalfOfUserId: process.env.MY_USER_ID,
  
  // Optional: Default company for business-related queries
  companyId: "biz_fsyAlxa8BZM1Ca", // Replace with your biz ID
});

// Token verifier for authenticating incoming requests
// This validates that requests come from legitimate Whop users
export const verifyUserToken = makeUserTokenVerifier({
  appId: process.env.WHOP_APP_ID ?? "fallback",
  dontThrow: true, // Return null instead of throwing on invalid tokens
});
```

**Key Concepts:**

- **App API Key**: Authenticates your app to Whop's API
- **User Token**: Proves a specific user is making the request
- **Experience Access**: Whop manages who can access what experiences

### Database Helper Functions

Create `lib/helpers.ts`:

```typescript lib/helpers.ts
import { whopApi } from "./whop-api";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

/**
 * Syncs a Whop Experience with our local database
 * This ensures we have the latest experience details
 */
export async function findOrCreateExperience(experienceId: string) {
  // Fetch current experience data from Whop
  const whopExperience = await whopApi.GetExperience({ experienceId });
  const experienceName = whopExperience.experience.name;
  const bizName = whopExperience.experience.company.title;
  const bizId = whopExperience.experience.company.id;

  // Check if we already have this experience in our database
  let experience = await prisma.experience.findUnique({
    where: { id: experienceId },
    include: { places: true }, // Include all places for this experience
  });

  if (!experience) {
    // First time setup - create new experience record
    experience = await prisma.experience.create({
      data: {
        id: experienceId,
        title: experienceName,
        bizName,
        bizId,
        webhookUrl: "", // Can be configured later
      },
      include: { places: true },
    });
    
    // Optional: Send notification about new installation
    sendWhopWebhook({
      content: "Someone installed the map places app in their whop!",
    });
  } else {
    // Update existing experience with latest Whop data
    experience = await prisma.experience.update({
      where: { id: experienceId },
      data: { title: experienceName, bizName, bizId },
      include: { places: true },
    });
  }
  
  return experience;
}

/**
 * Creates a new place in the database
 * Only admins should be able to call this
 */
export async function createPlace({
  experienceId,
  name,
  description,
  latitude,
  longitude,
  address,
  category,
}: {
  experienceId: string;
  name: string;
  description?: string;
  latitude: number;
  longitude: number;
  address?: string;
  category?: string;
}) {
  return await prisma.place.create({
    data: {
      experienceId,
      name,
      description,
      latitude,
      longitude,
      address,
      category,
    },
  });
}

/**
 * Fetches all places for an experience
 * Both admins and customers can call this
 */
export async function getPlaces(experienceId: string) {
  return await prisma.place.findMany({
    where: { experienceId },
    orderBy: { createdAt: 'desc' },
  });
}

/**
 * Deletes a place from the database
 * Only admins should be able to call this
 */
export async function deletePlace(placeId: string) {
  return await prisma.place.delete({
    where: { id: placeId },
  });
}

// ... webhook helper function for notifications
export async function sendWhopWebhook({
  content,
  experienceId = "exp_QccW4l1rRJok5d", // Default experience
}: {
  content: string;
  experienceId?: string;
}) {
  const payload = { content };
  
  const experience = await prisma.experience.findUnique({
    where: { id: experienceId },
  });

  const webhookUrl = experience?.webhookUrl || process.env.DEFAULT_WEBHOOK_URL || "";

  if (!webhookUrl || webhookUrl.trim() === "") {
    console.log("No webhook URL configured, skipping webhook");
    return;
  }

  try {
    const response = await fetch(webhookUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      console.error(`Webhook failed with status ${response.status}`);
    }
  } catch (error) {
    console.error("Error sending webhook:", error);
  }
}
```

## 5. Get Your Mapbox Token

1. Go to [Mapbox](https://mapbox.com) and create a free account
2. Navigate to your [Account page](https://account.mapbox.com/)
3. Copy your default public token (starts with `pk.`)
4. Add it to your `.env.local`:

```env .env.local
NEXT_PUBLIC_MAPBOX_TOKEN=pk.your_mapbox_token_here
```

## 6. Install Map Dependencies

<CodeGroup>
```bash pnpm
pnpm add mapbox-gl @radix-ui/react-slot class-variance-authority clsx tailwind-merge lucide-react
```

```bash npm
npm install mapbox-gl @radix-ui/react-slot class-variance-authority clsx tailwind-merge lucide-react
```

```bash yarn
yarn add mapbox-gl @radix-ui/react-slot class-variance-authority clsx tailwind-merge lucide-react
```
</CodeGroup>

Add Shadcn button component:

<CodeGroup>
```bash pnpm
pnpm dlx shadcn@latest add button
```

```bash npm
npx shadcn@latest add button
```

```bash yarn
yarn shadcn@latest add button
```
</CodeGroup>

## 7. Main Experience Page

Create `app/experiences/[experienceId]/page.tsx`:

```typescript app/experiences/[experienceId]/page.tsx
import { findOrCreateExperience } from "@/lib/helpers";
import { headers } from "next/headers";
import { whopApi, verifyUserToken } from "@/lib/whop-api";
import MapView from "@/components/MapView";

interface PageProps {
  params: Promise<{ experienceId: string }>;
}

export default async function ExperiencePage({ params }: PageProps) {
  const { experienceId } = await params;
  const headersList = await headers();
  
  // Verify the user token from the request headers
  // This ensures only legitimate Whop users can access the page
  const userToken = await verifyUserToken(headersList);

  if (!userToken) {
    return <div>Please log in to access this experience.</div>;
  }

  // Sync Whop experience data with our local database
  const experience = await findOrCreateExperience(experienceId);

  // Check if this specific user has access to this specific experience
  // This is where Whop's access control magic happens
  const hasAccess = await whopApi.CheckIfUserHasAccessToExperience({
    userId: userToken.userId,
    experienceId: experienceId,
  });

  if (!hasAccess.hasAccessToExperience.hasAccess) {
    return <div>You don't have access to this experience.</div>;
  }

  return (
    <div className="flex flex-col h-screen relative">
      {/* Info card showing experience details and user's access level */}
      <div className="absolute top-4 left-4 z-10 bg-white/95 backdrop-blur-md border border-white/20 rounded-lg px-3 py-2 shadow-lg max-w-xs">
        <h1 className="text-sm font-semibold text-gray-900 truncate">
          {experience.title}
        </h1>
        <p className="text-xs text-gray-600">
          {hasAccess.hasAccessToExperience.accessLevel === "admin" 
            ? "Admin access" 
            : "View Places"}
        </p>
      </div>

      <div className="flex-1">
        <MapView
          places={experience.places || []}
          accessLevel={hasAccess.hasAccessToExperience.accessLevel as "admin" | "customer" | "no_access"}
          experienceId={experienceId}
        />
      </div>
    </div>
  );
}
```

**Key Decisions Explained:**

1. **Server Component**: We use server-side rendering to securely verify user access before showing any content
2. **Token Verification**: `verifyUserToken()` ensures requests come from legitimate Whop users
3. **Access Check**: `CheckIfUserHasAccessToExperience()` determines what the user can see/do
4. **Database Sync**: `findOrCreateExperience()` keeps our local data in sync with Whop

## 8. TypeScript Definitions

Create `components/map/types.ts`:

```typescript components/map/types.ts
// Database model type - matches our Prisma schema
export interface Place {
  id: string;
  name: string;
  description?: string;
  category?: string;
  address?: string;
  latitude: number;
  longitude: number;
  createdAt: Date;
  updatedAt: Date;
  experienceId: string;
}

// For creating new places
export interface NewPlacePosition {
  lng: number;
  lat: number;
}

// Main component props
export interface MapViewProps {
  places: Place[];
  accessLevel: "admin" | "customer" | "no_access";
  experienceId: string;
}

// Mapbox geocoding API response
export interface GeocodingResult {
  features: Array<{
    place_name: string;
    center: [number, number];
  }>;
}
```

## 9. Map Utilities

Create `components/map/utils.ts`:

```typescript components/map/utils.ts
import type { GeocodingResult } from './types';

/**
 * Converts an address string into GPS coordinates using Mapbox Geocoding API
 * This allows users to add places by typing an address instead of clicking
 */
export const geocodeAddress = async (address: string): Promise<{
  lng: number;
  lat: number;
  fullAddress: string;
} | null> => {
  const mapboxToken = process.env.NEXT_PUBLIC_MAPBOX_TOKEN;
  if (!mapboxToken) return null;

  try {
    const response = await fetch(
      `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(address)}.json?access_token=${mapboxToken}&limit=1`
    );
    
    const data: GeocodingResult = await response.json();
    
    if (data.features && data.features.length > 0) {
      const feature = data.features[0];
      return {
        lng: feature.center[0],
        lat: feature.center[1],
        fullAddress: feature.place_name,
      };
    }
    
    return null;
  } catch (error) {
    console.error('Geocoding error:', error);
    return null;
  }
};

/**
 * Checks if a point is currently visible in the map viewport
 * Useful for optimizing marker rendering
 */
export const isPointVisible = (map: any, point: [number, number]): boolean => {
  const bounds = map.getBounds();
  return bounds.contains(point);
};
```

## 10. Map Styling

Create `components/map/styles.ts`:

```typescript components/map/styles.ts
// Main map container styling for 3D globe effect
export const mapStyles = `
  .mapboxgl-map {
    position: absolute !important;
    top: 0 !important;
    bottom: 0 !important;
    left: 0 !important;
    right: 0 !important;
    width: 100% !important;
    height: 100% !important;
    background: rgb(12, 12, 35) !important; /* Space-like background */
  }
  
  .mapboxgl-canvas {
    position: absolute !important;
    width: 100% !important;
    height: 100% !important;
    outline: none !important;
    /* Subtle color adjustments for better visual appeal */
    filter: brightness(0.9) contrast(1.05) saturate(0.95) !important;
  }
  
  /* Hide default Mapbox controls - we'll create custom ones */
  .mapboxgl-control-container {
    display: none !important;
  }
  
  /* Custom popup styling for place details */
  .place-popup {
    background: rgba(255, 255, 255, 0.98) !important;
    backdrop-filter: blur(10px) !important;
    border-radius: 12px !important;
    padding: 0 !important;
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.15) !important;
    border: 1px solid rgba(255, 255, 255, 0.1) !important;
    z-index: 999 !important;
    pointer-events: auto !important;
  }
  
  .place-popup .mapboxgl-popup-content {
    background: transparent !important;
    padding: 0 !important;
    border-radius: 12px !important;
    pointer-events: auto !important;
  }
  
  /* Remove default popup arrow */
  .place-popup .mapboxgl-popup-tip {
    display: none !important;
  }
  
  /* Place information display */
  .place-info {
    padding: 16px;
    min-width: 200px;
    pointer-events: auto;
    position: relative;
    z-index: 1000;
  }
  
  .place-info h3 {
    margin: 0 0 8px 0;
    color: #1a1a1a;
    font-size: 15px;
    font-weight: 600;
    letter-spacing: -0.2px;
  }
  
  .place-info .place-description {
    margin: 0 0 8px 0;
    color: #666;
    font-size: 13px;
  }
  
  .place-info .place-category {
    margin: 0 0 4px 0;
    color: #4f46e5;
    font-size: 12px;
    font-weight: 500;
  }
  
  .place-info .place-location {
    margin: 0 0 12px 0;
    color: #999;
    font-size: 12px;
  }
  
  /* Delete button for admin users */
  .delete-btn {
    background: #dc2626;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 500;
    width: 100%;
    transition: background 0.2s ease;
    pointer-events: auto;
  }
  
  .delete-btn:hover {
    background: #b91c1c;
  }
  
  /* Custom marker pin styling */
  .custom-marker {
    width: 24px;
    height: 30px;
    cursor: pointer;
  }
  
  .custom-marker:hover {
    opacity: 0.8;
  }
`;

// Control panel styling for admin place management
export const controlPanelStyles = `
  .places-controls {
    position: absolute !important;
    bottom: 20px !important;
    left: 20px !important;
    background: rgba(255, 255, 255, 0.95) !important;
    backdrop-filter: blur(10px) !important;
    border-radius: 10px !important;
    padding: 12px !important;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12) !important;
    z-index: 1 !important;
    width: 240px !important;
    border: 1px solid rgba(255, 255, 255, 0.2) !important;
  }
  
  .control-button {
    background: white !important;
    border: 1px solid rgba(0, 0, 0, 0.1) !important;
    padding: 8px 12px !important;
    border-radius: 6px !important;
    cursor: pointer !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    width: 100% !important;
    font-weight: 500 !important;
    color: #1a1a1a !important;
    font-size: 12px !important;
    transition: all 0.2s ease !important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05) !important;
    margin-bottom: 4px !important;
  }
  
  .control-button:hover {
    background: #f8f8f8 !important;
    transform: translateY(-1px) !important;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1) !important;
  }
  
  .control-button.active {
    background: #f0f0f0 !important;
    border-color: rgba(0, 0, 0, 0.15) !important;
    color: #000 !important;
  }
  
  .control-input {
    width: 100% !important;
    padding: 6px 8px !important;
    border: 1px solid rgba(0, 0, 0, 0.1) !important;
    border-radius: 4px !important;
    font-size: 11px !important;
    margin-bottom: 6px !important;
    background: white !important;
    box-sizing: border-box !important;
  }
  
  .control-input::placeholder {
    color: #999 !important;
  }
  
  .control-status {
    font-size: 10px !important;
    color: #10b981 !important;
    margin-bottom: 8px !important;
    text-align: center !important;
  }
  
  .control-actions {
    display: flex !important;
    gap: 6px !important;
    margin-top: 6px !important;
  }
`;
```

**Styling Decisions Explained:**

1. **Glass Morphism**: Semi-transparent backgrounds with blur for modern look
2. **Z-Index Management**: Ensures controls appear above the 3D globe
3. **Responsive Design**: Controls adapt to different screen sizes
4. **Accessibility**: Clear contrast ratios and hover states

## 11. API Routes

### Create Place API

Create `app/api/experiences/[experienceId]/places/route.ts`:

```typescript app/api/experiences/[experienceId]/places/route.ts
import { NextResponse } from "next/server";
import { verifyUserToken, whopApi } from "@/lib/whop-api";
import { headers } from "next/headers";
import { createPlace, getPlaces } from "@/lib/helpers";

/**
 * GET /api/experiences/[experienceId]/places
 * Fetches all places for an experience
 * Available to both admins and customers
 */
export async function GET(request: Request) {
  try {
    // Extract experience ID from URL
    const url = new URL(request.url);
    const match = url.pathname.match(/experiences\/([^/]+)\/places/);
    const experienceId = match ? match[1] : null;

    if (!experienceId) {
      return NextResponse.json(
        { error: "Missing experienceId" },
        { status: 400 }
      );
    }

    // Verify user authentication
    const headersList = await headers();
    const userToken = await verifyUserToken(headersList);
    if (!userToken) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Check if user has access to this experience
    const hasAccess = await whopApi.CheckIfUserHasAccessToExperience({
      userId: userToken.userId,
      experienceId,
    });

    if (!hasAccess.hasAccessToExperience.hasAccess) {
      return NextResponse.json(
        { error: "Unauthorized, no access" },
        { status: 401 }
      );
    }

    // Fetch and return places
    const places = await getPlaces(experienceId);
    return NextResponse.json(places);
  } catch (error) {
    console.error("Error fetching places:", error);
    return NextResponse.json(
      { error: "Failed to fetch places" },
      { status: 500 }
    );
  }
}

/**
 * POST /api/experiences/[experienceId]/places
 * Creates a new place
 * Only available to admin users
 */
export async function POST(request: Request) {
  try {
    // Extract experience ID from URL
    const url = new URL(request.url);
    const match = url.pathname.match(/experiences\/([^/]+)\/places/);
    const experienceId = match ? match[1] : null;

    if (!experienceId) {
      return NextResponse.json(
        { error: "Missing experienceId" },
        { status: 400 }
      );
    }

    // Verify user authentication
    const headersList = await headers();
    const userToken = await verifyUserToken(headersList);
    if (!userToken) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Check if user has ADMIN access (not just customer access)
    const hasAccess = await whopApi.CheckIfUserHasAccessToExperience({
      userId: userToken.userId,
      experienceId,
    });

    if (hasAccess.hasAccessToExperience.accessLevel !== "admin") {
      return NextResponse.json(
        { error: "Unauthorized, admin access required" },
        { status: 401 }
      );
    }

    // Parse request body
    const { name, description, latitude, longitude, address, category } =
      await request.json();

    // Validate required fields
    if (!name || typeof latitude !== "number" || typeof longitude !== "number") {
      return NextResponse.json(
        { error: "Name, latitude, and longitude are required" },
        { status: 400 }
      );
    }

    // Create the place
    const place = await createPlace({
      experienceId,
      name,
      description,
      latitude,
      longitude,
      address,
      category,
    });

    return NextResponse.json(place);
  } catch (error) {
    console.error("Error creating place:", error);
    return NextResponse.json(
      { error: "Failed to create place" },
      { status: 500 }
    );
  }
}
```

### Delete Place API

Create `app/api/experiences/[experienceId]/places/[placeId]/route.ts`:

```typescript app/api/experiences/[experienceId]/places/[placeId]/route.ts
import { NextResponse } from "next/server";
import { verifyUserToken, whopApi } from "@/lib/whop-api";
import { headers } from "next/headers";
import { deletePlace } from "@/lib/helpers";

/**
 * DELETE /api/experiences/[experienceId]/places/[placeId]
 * Deletes a specific place
 * Only available to admin users
 */
export async function DELETE(request: Request) {
  try {
    // Extract IDs from URL path
    const url = new URL(request.url);
    const pathMatch = url.pathname.match(/experiences\/([^/]+)\/places\/([^/]+)/);
    const experienceId = pathMatch ? pathMatch[1] : null;
    const placeId = pathMatch ? pathMatch[2] : null;

    if (!experienceId || !placeId) {
      return NextResponse.json(
        { error: "Missing experienceId or placeId" },
        { status: 400 }
      );
    }

    // Verify user authentication
    const headersList = await headers();
    const userToken = await verifyUserToken(headersList);
    if (!userToken) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Ensure user has admin access
    const hasAccess = await whopApi.CheckIfUserHasAccessToExperience({
      userId: userToken.userId,
      experienceId,
    });

    if (hasAccess.hasAccessToExperience.accessLevel !== "admin") {
      return NextResponse.json(
        { error: "Unauthorized, admin access required" },
        { status: 401 }
      );
    }

    // Delete the place
    await deletePlace(placeId);
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting place:", error);
    return NextResponse.json(
      { error: "Failed to delete place" },
      { status: 500 }
    );
  }
}
```

**API Design Decisions:**

1. **RESTful Structure**: Clear URL patterns that map to database operations
2. **Double Authentication**: Verify both user token AND experience access
3. **Role-Based Access**: Different permissions for admin vs customer
4. **Error Handling**: Comprehensive error responses with proper HTTP status codes
5. **Input Validation**: Ensure required fields are present and correctly typed

## 12. Main MapView Component

Create `components/MapView.tsx`:

```typescript components/MapView.tsx
"use client";

import { useRef, useState } from 'react';
import mapboxgl from 'mapbox-gl';
import type { MapViewProps, NewPlacePosition } from './map/types';
import MapContainer from './map/MapContainer';
import PlaceControlPanel from './map/PlaceControlPanel';
import PlacesList from './map/PlacesList';

/**
 * Creates a custom SVG pin marker for places on the map
 * Why SVG? It scales perfectly at all zoom levels and allows custom colors
 */
const createPinMarker = (color = '#dc2626') => {
  const markerEl = document.createElement('div');
  markerEl.innerHTML = `
    <svg width="24" height="30" viewBox="0 0 24 30" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M12 0C5.372 0 0 5.372 0 12C0 18.628 12 30 12 30S24 18.628 24 12C24 5.372 18.628 0 12 0Z" fill="${color}"/>
      <circle cx="12" cy="12" r="4" fill="white"/>
    </svg>
  `;
  markerEl.style.cursor = 'pointer';
  markerEl.style.width = '24px';
  markerEl.style.height = '30px';
  markerEl.style.display = 'block';
  markerEl.style.border = 'none';
  markerEl.style.borderRadius = '0';
  markerEl.style.padding = '0';
  return markerEl;
};

export default function MapView({
  places,
  accessLevel,
  experienceId,
}: MapViewProps) {
  // State for managing place creation mode
  const [isAddingPlace, setIsAddingPlace] = useState(false);
  const [newPlacePosition, setNewPlacePosition] = useState<NewPlacePosition | null>(null);
  
  // Refs for managing map and marker instances
  const newMarkerRef = useRef<mapboxgl.Marker | null>(null);
  const mapRef = useRef<mapboxgl.Map | null>(null);

  /**
   * Updates the preview marker when user clicks to add a new place
   * Green color indicates this is a "pending" place that hasn't been saved yet
   */
  const updateNewMarker = (lng: number, lat: number) => {
    if (!mapRef.current) return;
    
    // Remove any existing preview marker
    if (newMarkerRef.current) {
      newMarkerRef.current.remove();
    }
    
    // Create green pin to show where new place will be added
    const markerEl = createPinMarker('#10b981'); // Green = "new"
    
    // Add marker with proper bottom anchor (pin points to exact location)
    newMarkerRef.current = new mapboxgl.Marker({ 
      element: markerEl,
      anchor: 'bottom' // Pin tip points to the exact coordinates
    })
      .setLngLat([lng, lat])
      .addTo(mapRef.current);
  };

  /**
   * Handles place deletion with confirmation
   * Only admins can delete places
   */
  const handleDeletePlace = async (placeId: string) => {
    if (!confirm("Are you sure you want to delete this place?")) return;

    try {
      const response = await fetch(
        `/api/experiences/${experienceId}/places/${placeId}`,
        { method: "DELETE" }
      );

      if (!response.ok) {
        throw new Error("Failed to delete place");
      }

      // Refresh page to show updated places list
      // In production, you might want to use more sophisticated state management
      window.location.reload();
    } catch (error) {
      console.error("Error deleting place:", error);
    }
  };

  /**
   * Callback when map is fully loaded and ready
   */
  const handleMapReady = (map: mapboxgl.Map) => {
    mapRef.current = map;
  };

  // Handle case where user doesn't have access
  if (accessLevel === "no_access") {
    return (
      <div className="flex items-center justify-center h-64 text-gray-400 bg-[rgb(12,12,35)]">
        You don't have access to view this map.
      </div>
    );
  }

  const mapboxToken = process.env.NEXT_PUBLIC_MAPBOX_TOKEN;
  
  // Fallback to places list if no Mapbox token (graceful degradation)
  if (!mapboxToken) {
    return (
      <PlacesList 
        places={places}
        accessLevel={accessLevel}
        onDeletePlace={handleDeletePlace}
      />
    );
  }

  return (
    <div className="w-full h-full relative overflow-hidden">
      {/* Main 3D map container */}
      <MapContainer
        places={places}
        accessLevel={accessLevel}
        experienceId={experienceId}
        isAddingPlace={isAddingPlace}
        newPlacePosition={newPlacePosition}
        setNewPlacePosition={setNewPlacePosition}
        updateNewMarker={updateNewMarker}
        onDeletePlace={handleDeletePlace}
        onMapReady={handleMapReady}
      />
      
      {/* Admin control panel - only show for admin users */}
      {accessLevel === "admin" && (
        <PlaceControlPanel
          experienceId={experienceId}
          isAddingPlace={isAddingPlace}
          setIsAddingPlace={setIsAddingPlace}
          newPlacePosition={newPlacePosition}
          setNewPlacePosition={setNewPlacePosition}
          updateNewMarker={updateNewMarker}
          map={mapRef.current}
        />
      )}
    </div>
  );
}
```

**Key Design Decisions:**

1. **Conditional Rendering**: Different UI for admin vs customer users
2. **Graceful Degradation**: Falls back to list view if Mapbox token missing
3. **State Management**: Local state for place creation workflow
4. **Ref Management**: Direct DOM manipulation for optimal map performance

## 13. 3D Map Container

Create `components/map/MapContainer.tsx`:

```typescript components/map/MapContainer.tsx
"use client";

import { useEffect, useRef } from 'react';
import mapboxgl from 'mapbox-gl';
import 'mapbox-gl/dist/mapbox-gl.css';
import type { Place, NewPlacePosition } from './types';
import { mapStyles } from './styles';

interface MapContainerProps {
  places: Place[];
  accessLevel: "admin" | "customer" | "no_access";
  experienceId: string;
  isAddingPlace: boolean;
  newPlacePosition: NewPlacePosition | null;
  setNewPlacePosition: (position: NewPlacePosition | null) => void;
  updateNewMarker: (lng: number, lat: number) => void;
  onDeletePlace: (placeId: string) => Promise<void>;
  onMapReady: (map: mapboxgl.Map) => void;
}

/**
 * Creates a custom SVG pin marker
 * This is the same function as in MapView - consider extracting to utils
 */
const createPinMarker = (color = '#dc2626') => {
  const markerEl = document.createElement('div');
  markerEl.className = 'custom-marker';
  markerEl.innerHTML = `
    <svg width="24" height="30" viewBox="0 0 24 30" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M12 0C5.372 0 0 5.372 0 12C0 18.628 12 30 12 30S24 18.628 24 12C24 5.372 18.628 0 12 0Z" fill="${color}"/>
      <circle cx="12" cy="12" r="4" fill="white"/>
    </svg>
  `;
  return markerEl;
};

export default function MapContainer({
  places,
  accessLevel,
  experienceId,
  isAddingPlace,
  newPlacePosition,
  setNewPlacePosition,
  updateNewMarker,
  onDeletePlace,
  onMapReady
}: MapContainerProps) {
  const mapContainer = useRef<HTMLDivElement>(null);
  const map = useRef<mapboxgl.Map | null>(null);
  const markersRef = useRef<mapboxgl.Marker[]>([]);

  useEffect(() => {
    // Prevent double initialization
    if (!mapContainer.current || map.current) return;

    const mapboxToken = process.env.NEXT_PUBLIC_MAPBOX_TOKEN;
    if (!mapboxToken) return;

    mapboxgl.accessToken = mapboxToken;

    // Slight delay to ensure DOM is ready
    setTimeout(() => {
      try {
        if (!mapContainer.current) return;
        
        // Initialize Mapbox map with 3D globe projection
        const mapInstance = new mapboxgl.Map({
          container: mapContainer.current,
          style: 'mapbox://styles/mapbox/standard', // Clean, modern base style
          center: [-90, 25], // Center on North America
          zoom: 2, // Global view
          projection: 'globe' as any, // 3D globe projection
          antialias: true, // Smooth edges
          renderWorldCopies: false, // Don't repeat the world
          maxZoom: 20,
          minZoom: 1
        });

        // Handle window resizing
        const resizeObserver = new ResizeObserver((entries) => {
          if (mapInstance) {
            setTimeout(() => {
              mapInstance.resize();
            }, 0);
          }
        });

        if (mapContainer.current) {
          resizeObserver.observe(mapContainer.current);
        }

        mapInstance.on('load', () => {
          // Configure 3D atmosphere effect
          mapInstance.setFog({
            color: 'rgba(140, 195, 255, 0.5)', // Sky blue atmosphere
            'high-color': 'rgba(243, 181, 255, 0.4)', // Purple highlights
            'horizon-blend': 0.03, // Smooth horizon transition
            'space-color': 'rgb(12, 12, 35)', // Dark space background
            'star-intensity': 0.6 // Subtle star field
          });

          // Add markers for each existing place
          places.forEach(place => {
            // Create red pin marker for existing places
            const markerEl = createPinMarker('#dc2626');
            
            // Create popup with place information
            const popup = new mapboxgl.Popup({ offset: 25 })
              .setHTML(`
                <div class="place-info">
                  <h3>${place.name}</h3>
                  ${place.description ? `<p class="place-description">${place.description}</p>` : ''}
                  ${place.category ? `<p class="place-category">${place.category}</p>` : ''}
                  ${place.address ? `<p class="place-location">${place.address}</p>` : ''}
                  ${accessLevel === "admin" ? `
                    <button onclick="window.deletePlace('${place.id}')" class="delete-btn">
                      Delete Place
                    </button>
                  ` : ''}
                </div>
              `);
            
            // Create marker with popup
            const marker = new mapboxgl.Marker({ 
              element: markerEl,
              anchor: 'bottom' // Pin tip points to exact coordinates
            })
              .setLngLat([place.longitude, place.latitude])
              .setPopup(popup) // Attach popup to marker
              .addTo(mapInstance);

            markersRef.current.push(marker);
          });

          // Handle map clicks for adding new places (admin only)
          if (accessLevel === "admin") {
            mapInstance.on('click', (e) => {
              if (isAddingPlace) {
                const { lng, lat } = e.lngLat;
                setNewPlacePosition({ lng, lat });
                updateNewMarker(lng, lat);
              }
            });
          }

          // Remove unnecessary map layers for cleaner look
          ['land-structure-line', 'waterway-label', 'natural-point-label', 
           'water-point-label', 'water-line-label'].forEach(layer => {
            if (mapInstance.getLayer(layer)) {
              mapInstance.removeLayer(layer);
            }
          });
          
          // Add custom country boundaries
          mapInstance.addSource('country-boundaries', {
            type: 'vector',
            url: 'mapbox://mapbox.country-boundaries-v1'
          });

          mapInstance.addLayer({
            id: 'country-boundaries',
            type: 'line',
            source: 'country-boundaries',
            'source-layer': 'country_boundaries',
            paint: {
              'line-color': 'rgba(255, 182, 193, 0.3)', // Subtle pink borders
              'line-width': 0.4,
              'line-opacity': 0.4
            }
          });

          // Configure lighting for 3D effect
          mapInstance.setLight({
            intensity: 0.15, // Subtle lighting
            color: 'rgb(215, 205, 245)', // Soft purple light
            anchor: 'map' // Light follows map rotation
          });

          // Ensure map renders properly
          mapInstance.resize();
        });

        map.current = mapInstance;
        onMapReady(mapInstance);

        // Make delete function globally available for popup buttons
        (window as any).deletePlace = onDeletePlace;

        // Handle window resize events
        const handleResize = () => {
          if (map.current) {
            map.current.resize();
          }
        };

        window.addEventListener('resize', handleResize);
        
        // Cleanup function
        return () => {
          window.removeEventListener('resize', handleResize);
          resizeObserver.disconnect();
          markersRef.current.forEach((marker: mapboxgl.Marker) => marker.remove());
          if (map.current) {
            map.current.remove();
          }
        };
      } catch (error) {
        console.error('Error initializing map:', error);
      }
    }, 100);
  }, [places, accessLevel, experienceId, isAddingPlace, setNewPlacePosition, updateNewMarker, onDeletePlace, onMapReady]);

  return (
    <>
      {/* Inject map styles */}
      <style dangerouslySetInnerHTML={{ __html: mapStyles }} />
      
      {/* Map container */}
      <div 
        ref={mapContainer} 
        className="w-full h-full"
        style={{ position: 'relative' }}
      />
    </>
  );
}
```

**3D Globe Implementation Decisions:**

1. **Globe Projection**: Creates an impressive 3D sphere effect
2. **Atmosphere Styling**: Adds realistic space-like environment
3. **Custom Lighting**: Enhances 3D appearance
4. **Layer Management**: Removes clutter for cleaner visuals
5. **Performance**: Uses refs to avoid unnecessary re-renders

## 14. Admin Control Panel

Create `components/map/PlaceControlPanel.tsx`:

```typescript components/map/PlaceControlPanel.tsx
"use client";

import { useState } from 'react';
import type { NewPlacePosition } from './types';
import { geocodeAddress } from './utils';
import { controlPanelStyles } from './styles';

interface PlaceControlPanelProps {
  experienceId: string;
  isAddingPlace: boolean;
  setIsAddingPlace: (value: boolean) => void;
  newPlacePosition: NewPlacePosition | null;
  setNewPlacePosition: (position: NewPlacePosition | null) => void;
  updateNewMarker: (lng: number, lat: number) => void;
  map: any;
}

export default function PlaceControlPanel({
  experienceId,
  isAddingPlace,
  setIsAddingPlace,
  newPlacePosition,
  setNewPlacePosition,
  updateNewMarker,
  map
}: PlaceControlPanelProps) {
  // Form state for new place creation
  const [newPlaceName, setNewPlaceName] = useState("");
  const [newPlaceDescription, setNewPlaceDescription] = useState("");
  const [newPlaceCategory, setNewPlaceCategory] = useState("");
  const [newPlaceAddress, setNewPlaceAddress] = useState("");
  const [isGeocoding, setIsGeocoding] = useState(false);

  /**
   * Converts typed address to GPS coordinates using Mapbox Geocoding API
   * This allows users to add places by typing addresses instead of just clicking
   */
  const handleAddressGeocode = async () => {
    if (!newPlaceAddress.trim() || !map) return;
    
    setIsGeocoding(true);
    const result = await geocodeAddress(newPlaceAddress);
    setIsGeocoding(false);
    
    if (result) {
      setNewPlacePosition({ lng: result.lng, lat: result.lat });
      setNewPlaceAddress(result.fullAddress); // Use the full formatted address
      
      // Fly to the geocoded location and show preview marker
      map.flyTo({ center: [result.lng, result.lat], zoom: 6 });
      updateNewMarker(result.lng, result.lat);
    } else {
      alert('Could not find that address. Please try a different address or click on the map.');
    }
  };

  /**
   * Submits new place to the API
   * Validates required fields and handles form reset
   */
  const handleAddPlace = async () => {
    if (!newPlacePosition || !newPlaceName.trim()) return;

    const newPlace = {
      name: newPlaceName,
      description: newPlaceDescription || null,
      latitude: newPlacePosition.lat,
      longitude: newPlacePosition.lng,
      address: newPlaceAddress || null,
      category: newPlaceCategory || null,
    };

    try {
      const response = await fetch(`/api/experiences/${experienceId}/places`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(newPlace),
      });

      if (!response.ok) {
        throw new Error("Failed to add place");
      }

      // Reset form and refresh page to show new place
      resetForm();
      window.location.reload();
    } catch (error) {
      console.error("Error adding place:", error);
    }
  };

  /**
   * Resets all form fields and exit add mode
   */
  const resetForm = () => {
    setNewPlaceName("");
    setNewPlaceDescription("");
    setNewPlaceCategory("");
    setNewPlaceAddress("");
    setNewPlacePosition(null);
    setIsAddingPlace(false);
  };

  return (
    <>
      {/* Inject control panel styles */}
      <style dangerouslySetInnerHTML={{ __html: controlPanelStyles }} />
      
      <div className="places-controls">
        {/* Toggle add place mode */}
        <button 
          className={`control-button ${isAddingPlace ? 'active' : ''}`}
          onClick={() => setIsAddingPlace(!isAddingPlace)}
        >
          {isAddingPlace ? '✕ Cancel' : '+ Add Place'}
        </button>

        {isAddingPlace && (
          <>
            {/* Place name input - required field */}
            <input
              type="text"
              placeholder="Place name *"
              value={newPlaceName}
              onChange={(e) => setNewPlaceName(e.target.value)}
              className="control-input"
            />
            
            {/* Description input - optional */}
            <input
              type="text"
              placeholder="Description"
              value={newPlaceDescription}
              onChange={(e) => setNewPlaceDescription(e.target.value)}
              className="control-input"
            />
            
            {/* Category input - optional, for grouping places */}
            <input
              type="text"
              placeholder="Category"
              value={newPlaceCategory}
              onChange={(e) => setNewPlaceCategory(e.target.value)}
              className="control-input"
            />
            
            {/* Address input with geocoding */}
            <input
              type="text"
              placeholder="Address"
              value={newPlaceAddress}
              onChange={(e) => setNewPlaceAddress(e.target.value)}
              className="control-input"
            />
            
            {/* Geocode address button */}
            <button
              onClick={handleAddressGeocode}
              disabled={!newPlaceAddress.trim() || isGeocoding}
              className="control-button"
              style={{ fontSize: '11px', marginBottom: '8px' }}
            >
              {isGeocoding ? 'Searching...' : 'Find Address'}
            </button>
            
            {/* Show coordinates when position is selected */}
            {newPlacePosition && (
              <div className="control-status">
                ✓ Position: {newPlacePosition.lat.toFixed(4)}, {newPlacePosition.lng.toFixed(4)}
              </div>
            )}

            {/* Action buttons - only show when position is set */}
            {newPlacePosition && (
              <div className="control-actions">
                <button 
                  onClick={handleAddPlace} 
                  disabled={!newPlaceName.trim()}
                  className="control-button"
                  style={{ 
                    background: '#10b981 !important', 
                    color: 'white !important', 
                    flex: '2', 
                    marginBottom: 0,
                    fontWeight: '600',
                    fontSize: '13px'
                  }}
                >
                  ✓ Add
                </button>
                <button
                  onClick={resetForm}
                  className="control-button"
                  style={{ 
                    background: '#dc2626 !important', 
                    color: 'white !important', 
                    flex: '1', 
                    padding: '8px', 
                    marginBottom: 0,
                    fontSize: '12px'
                  }}
                >
                  ✕
                </button>
              </div>
            )}
          </>
        )}
      </div>
    </>
  );
}
```

**Control Panel Design Decisions:**

1. **Progressive Disclosure**: Fields appear as needed in the workflow
2. **Dual Input Methods**: Users can click map OR type addresses
3. **Visual Feedback**: Clear status indicators for each step
4. **Form Validation**: Prevents submission without required fields
5. **Error Handling**: Graceful fallbacks for geocoding failures

## 15. Fallback Places List

Create `components/map/PlacesList.tsx`:

```typescript components/map/PlacesList.tsx
"use client";

import type { Place } from './types';

interface PlacesListProps {
  places: Place[];
  accessLevel: "admin" | "customer" | "no_access";
  onDeletePlace: (placeId: string) => Promise<void>;
}

/**
 * Fallback component when Mapbox is unavailable
 * Provides basic place management without the map visualization
 */
export default function PlacesList({
  places,
  accessLevel,
  onDeletePlace
}: PlacesListProps) {
  return (
    <div className="max-w-4xl mx-auto p-6">
      <div className="mb-6">
        <h1 className="text-2xl font-bold text-gray-900 mb-2">
          Places {accessLevel === "admin" ? "Management" : ""}
        </h1>
        <p className="text-gray-600">
          {places.length} place{places.length !== 1 ? 's' : ''} available
        </p>
      </div>

      {places.length === 0 ? (
        <div className="text-center py-12">
          <div className="text-gray-400 text-lg mb-2">No places added yet</div>
          {accessLevel === "admin" && (
            <p className="text-gray-500 text-sm">
              Add places to get started with your interactive map
            </p>
          )}
        </div>
      ) : (
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {places.map((place) => (
            <div
              key={place.id}
              className="bg-white rounded-lg border border-gray-200 p-4 shadow-sm hover:shadow-md transition-shadow"
            >
              <div className="flex justify-between items-start mb-2">
                <h3 className="font-semibold text-gray-900 text-lg">
                  {place.name}
                </h3>
                {accessLevel === "admin" && (
                  <button
                    onClick={() => onDeletePlace(place.id)}
                    className="text-red-600 hover:text-red-800 text-sm ml-2"
                  >
                    Delete
                  </button>
                )}
              </div>
              
              {place.description && (
                <p className="text-gray-600 text-sm mb-2">
                  {place.description}
                </p>
              )}
              
              {place.category && (
                <span className="inline-block bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full mb-2">
                  {place.category}
                </span>
              )}
              
              {place.address && (
                <p className="text-gray-500 text-xs mb-2">
                  📍 {place.address}
                </p>
              )}
              
              <div className="text-xs text-gray-400">
                {place.latitude.toFixed(4)}, {place.longitude.toFixed(4)}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
```

## 16. Production Deployment

### Environment Variables for Production

Update your production environment with:

```env
# Production Environment Variables
WHOP_APP_ID=app_your_production_app_id
WHOP_API_KEY=whop_your_production_api_key
MY_USER_ID=your_whop_user_id
DATABASE_URL=postgresql://your_production_db_url
DIRECT_URL=postgresql://your_production_direct_url
NEXT_PUBLIC_MAPBOX_TOKEN=pk.your_mapbox_token
NEXT_PUBLIC_APP_URL=https://your-production-domain.com

# Optional
DEFAULT_WEBHOOK_URL=https://your-webhook-endpoint.com
```

### Deployment Steps

1. **Push to GitHub**:
   ```bash
   git add .
   git commit -m "Complete places map implementation"
   git push origin main
   ```

2. **Deploy to Vercel**:
   - Connect your GitHub repository
   - Add all environment variables
   - Deploy

3. **Update Whop App Settings**:
   - Change redirect URL to your production domain
   - Update any webhook URLs
   - Switch from localhost to production mode

### Performance Optimizations

1. **Database Indexing**:
   ```sql
   CREATE INDEX idx_places_experience_id ON places(experienceId);
   CREATE INDEX idx_places_coordinates ON places(latitude, longitude);
   ```

2. **Mapbox Optimization**:
   - Use vector tiles for better performance
   - Implement marker clustering for many places
   - Add map bounds restrictions if needed

3. **Caching Strategy**:
   - Cache place data with Redis or similar
   - Implement incremental static regeneration
   - Use CDN for static assets

## 17. Advanced Features

### Marker Clustering

For experiences with many places, add clustering:

```typescript
// Add to MapContainer.tsx
import { ClusterLayer } from 'mapbox-gl-cluster';

// In map load event:
map.addSource('places-cluster', {
  type: 'geojson',
  data: {
    type: 'FeatureCollection',
    features: places.map(place => ({
      type: 'Feature',
      geometry: {
        type: 'Point',
        coordinates: [place.longitude, place.latitude]
      },
      properties: place
    }))
  },
  cluster: true,
  clusterMaxZoom: 14,
  clusterRadius: 50
});
```

### Automatic Forum Posts

Every time an admin adds a new place, the system automatically creates a forum post in the "Places Forum" that includes:

- **📍 Place name and details** 
- **🗺️ Direct link to view the place on the map**
- **📸 Mapbox Static image URL** of the location with a pin marker
- **🔔 Notification to all members**

The forum posts are created in a dedicated "Places Forum" within the same experience as your places map. This keeps your community engaged and informed about new additions to your map.

**How it works:**
1. Admin adds a place through the control panel
2. Place is saved to the database
3. System generates a Mapbox Static image URL with a pin marker
4. "Places Forum" is created using `CreateForum` API (if it doesn't exist)
5. Forum post is created with place details using `CreateForumPost` API
6. All members get notified about the new place (`isMention: true`)

**Forum Post Example:**
```
📍 New Place Added: SpaceX Headquarters

A new place has been added to the map! 🗺️

**Address:** 1 Rocket Road, Hawthorne, California 90250, United States
**Category:** Technology
**Description:** SpaceX headquarters and manufacturing facility

🔗 **View on Map**: https://your-app.com/experiences/exp_123

📸 **Location Image**: https://api.mapbox.com/styles/v1/mapbox/streets-v12/static/pin-s-marker+dc2626(-118.32803,33.920633)/-118.32803,33.920633,14,0/600x400@2x?access_token=pk.your_token

Click the link above to explore this location and all other places on our interactive map!
```

**Technical Implementation:**
- Uses Whop's `CreateForum` API to create the "Places Forum" experience  
- Creates rich forum posts with `CreateForumPost` API with correct parameters
- Includes direct links to map view and location images
- Handles errors gracefully with fallback logging and webhook notifications
- Notifies all community members when new places are added

### Search and Filtering

Add search functionality:

```typescript
// Add to PlaceControlPanel.tsx
const [searchQuery, setSearchQuery] = useState("");
const [categoryFilter, setCategoryFilter] = useState("");

const filteredPlaces = places.filter(place => 
  place.name.toLowerCase().includes(searchQuery.toLowerCase()) &&
  (!categoryFilter || place.category === categoryFilter)
);
```

### Real-time Updates

Implement real-time place updates:

```typescript
// Using WebSockets or Server-Sent Events
useEffect(() => {
  const eventSource = new EventSource(`/api/experiences/${experienceId}/places/stream`);
  
  eventSource.onmessage = (event) => {
    const update = JSON.parse(event.data);
    // Update places list without page reload
  };
  
  return () => eventSource.close();
}, [experienceId]);
```

## Summary

You've built a comprehensive places management application that demonstrates:

### Technical Achievements
- **3D Globe Visualization**: Beautiful Mapbox integration with custom markers
- **Role-Based Access Control**: Secure admin/customer permissions via Whop API
- **Real-time Database**: PostgreSQL with Prisma for reliable data management
- **Geocoding Integration**: Address-to-coordinates conversion
- **Responsive Design**: Works across all devices and screen sizes
- **Forum Integration**: Automatic community notifications for new places

### Business Value
- **Creator Monetization**: Sell access to curated place collections
- **Customer Engagement**: Interactive exploration experiences
- **Community Building**: Automatic forum posts keep users engaged
- **Scalable Architecture**: Easy to extend with new features
- **Professional Polish**: Production-ready with proper error handling

### Next Steps
1. **Add Analytics**: Track user engagement and popular places
2. **Implement Categories**: Better organization and filtering
3. **Add Media Upload**: Photos and videos for places
4. **Social Features**: Comments, ratings, and sharing
5. **Mobile App**: React Native version using same backend

Your places map application is now ready to launch and start generating revenue for creators on the Whop platform!

## Need Help?
- Join the [Developer Whop](https://whop.com/whop-devs)
- View the template [here](https://github.com/whopio/whop-nextjs-app-template)
- Visit our [SDK GitHub repository](https://github.com/whopio/whop-sdk-ts)
- DM @0ni_x4 on Discord
